package mq

import (
	"fmt"
	"sync"
	"time"

	amqp "github.com/rabbitmq/amqp091-go"
	"{{MODULE_PATH}}/pkg/logger"
)

// RabbitMQ å°è£… RabbitMQ è¿æ¥ç®¡ç†
type RabbitMQ struct {
	conn    *amqp.Connection
	channel *amqp.Channel
	url     string
	log     *logger.Logger
	mu      sync.RWMutex
	closed  bool
	done    chan struct{} // ç”¨äºé€šçŸ¥é‡è¿ goroutine é€€å‡º

	// é‡è¿ç›¸å…³
	reconnectDelay time.Duration
	maxRetries     int
}

// Config RabbitMQ é…ç½®
type Config struct {
	Host     string
	Port     int
	User     string
	Password string
	VHost    string
}

// New åˆ›å»º RabbitMQ è¿æ¥
func New(cfg *Config, log *logger.Logger) (*RabbitMQ, error) {
	url := fmt.Sprintf("amqp://%s:%s@%s:%d/%s",
		cfg.User, cfg.Password, cfg.Host, cfg.Port, cfg.VHost)

	mq := &RabbitMQ{
		url:            url,
		log:            log,
		done:           make(chan struct{}),
		reconnectDelay: 5 * time.Second,
		maxRetries:     10,
	}

	if err := mq.connect(); err != nil {
		return nil, err
	}

	// å¯åŠ¨é‡è¿ç›‘æ§
	go mq.handleReconnect()

	return mq, nil
}

// connect å»ºç«‹è¿æ¥
func (r *RabbitMQ) connect() error {
	r.mu.Lock()
	defer r.mu.Unlock()

	conn, err := amqp.Dial(r.url)
	if err != nil {
		return fmt.Errorf("failed to connect to RabbitMQ: %w", err)
	}

	channel, err := conn.Channel()
	if err != nil {
		conn.Close()
		return fmt.Errorf("failed to open channel: %w", err)
	}

	r.conn = conn
	r.channel = channel
	r.log.Info("ğŸ° Connected to RabbitMQ")

	return nil
}

// handleReconnect å¤„ç†æ–­çº¿é‡è¿
func (r *RabbitMQ) handleReconnect() {
	for {
		r.mu.RLock()
		if r.closed {
			r.mu.RUnlock()
			return
		}
		conn := r.conn
		r.mu.RUnlock()

		if conn == nil {
			select {
			case <-r.done:
				return
			case <-time.After(r.reconnectDelay):
				continue
			}
		}

		// ç›‘å¬è¿æ¥å…³é—­äº‹ä»¶
		notifyClose := conn.NotifyClose(make(chan *amqp.Error, 1))

		select {
		case <-r.done:
			// æ”¶åˆ°å…³é—­ä¿¡å·ï¼Œé€€å‡º goroutine
			return
		case err := <-notifyClose:
			if err != nil {
				r.log.Warn("RabbitMQ connection closed", logger.Error(err))
			}

			r.mu.RLock()
			if r.closed {
				r.mu.RUnlock()
				return
			}
			r.mu.RUnlock()

			// å°è¯•é‡è¿
			for i := 0; i < r.maxRetries; i++ {
				select {
				case <-r.done:
					return
				default:
				}

				r.log.Info("Attempting to reconnect to RabbitMQ",
					logger.Int("attempt", i+1),
					logger.Int("max_retries", r.maxRetries))

				if err := r.connect(); err != nil {
					r.log.Error("Failed to reconnect", logger.Error(err))
					select {
					case <-r.done:
						return
					case <-time.After(r.reconnectDelay):
						continue
					}
				}
				break
			}
		}
	}
}

// Channel è·å– channelï¼ˆçº¿ç¨‹å®‰å…¨ï¼‰
func (r *RabbitMQ) Channel() *amqp.Channel {
	r.mu.RLock()
	defer r.mu.RUnlock()
	return r.channel
}

// DeclareExchange å£°æ˜äº¤æ¢æœº
func (r *RabbitMQ) DeclareExchange(name, kind string) error {
	r.mu.RLock()
	defer r.mu.RUnlock()

	return r.channel.ExchangeDeclare(
		name,  // äº¤æ¢æœºåç§°
		kind,  // ç±»å‹: direct, fanout, topic, headers
		true,  // durable
		false, // auto-deleted
		false, // internal
		false, // no-wait
		nil,   // arguments
	)
}

// DeclareQueue å£°æ˜é˜Ÿåˆ—
func (r *RabbitMQ) DeclareQueue(name string) (amqp.Queue, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()

	return r.channel.QueueDeclare(
		name,  // é˜Ÿåˆ—åç§°
		true,  // durable
		false, // delete when unused
		false, // exclusive
		false, // no-wait
		nil,   // arguments
	)
}

// BindQueue ç»‘å®šé˜Ÿåˆ—åˆ°äº¤æ¢æœº
func (r *RabbitMQ) BindQueue(queueName, routingKey, exchangeName string) error {
	r.mu.RLock()
	defer r.mu.RUnlock()

	return r.channel.QueueBind(
		queueName,    // é˜Ÿåˆ—åç§°
		routingKey,   // routing key
		exchangeName, // äº¤æ¢æœºåç§°
		false,        // no-wait
		nil,          // arguments
	)
}

// Close å…³é—­è¿æ¥
func (r *RabbitMQ) Close() error {
	r.mu.Lock()
	defer r.mu.Unlock()

	if r.closed {
		return nil
	}
	r.closed = true

	// é€šçŸ¥é‡è¿ goroutine é€€å‡º
	close(r.done)

	if r.channel != nil {
		r.channel.Close()
	}
	if r.conn != nil {
		return r.conn.Close()
	}
	return nil
}
