package mq

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	amqp "github.com/rabbitmq/amqp091-go"
	"{{MODULE_PATH}}/pkg/logger"
)

const (
	// ExchangeName 默认交换机名称（所有微服务共用）
	ExchangeName = "uyou.events"
	// ExchangeKind 交换机类型（topic 支持路由键模式匹配）
	ExchangeKind = "topic"
)

// EventBus 事件总线
type EventBus struct {
	mq          *RabbitMQ
	log         *logger.Logger
	serviceName string
	handlers    map[string][]EventHandler
}

// Event 事件结构
type Event struct {
	ID        string          `json:"id"`
	Type      string          `json:"type"`
	Source    string          `json:"source"`
	Timestamp time.Time       `json:"timestamp"`
	Data      json.RawMessage `json:"data"`
}

// EventHandler 事件处理函数
type EventHandler func(ctx context.Context, event *Event) error

// NewEventBus 创建事件总线
func NewEventBus(mq *RabbitMQ, serviceName string, log *logger.Logger) (*EventBus, error) {
	eb := &EventBus{
		mq:          mq,
		log:         log,
		serviceName: serviceName,
		handlers:    make(map[string][]EventHandler),
	}

	// 声明交换机
	if err := mq.DeclareExchange(ExchangeName, ExchangeKind); err != nil {
		return nil, fmt.Errorf("failed to declare exchange: %w", err)
	}

	return eb, nil
}

// Publish 发布事件
//
// eventType: 事件类型，如 "user.blacklist.updated", "order.created"
// data: 事件数据，会被序列化为 JSON
func (eb *EventBus) Publish(ctx context.Context, eventType string, data interface{}) error {
	// 序列化数据
	dataBytes, err := json.Marshal(data)
	if err != nil {
		return fmt.Errorf("failed to marshal event data: %w", err)
	}

	// 构造事件
	event := Event{
		ID:        fmt.Sprintf("%s-%d", eb.serviceName, time.Now().UnixNano()),
		Type:      eventType,
		Source:    eb.serviceName,
		Timestamp: time.Now(),
		Data:      dataBytes,
	}

	// 序列化事件
	body, err := json.Marshal(event)
	if err != nil {
		return fmt.Errorf("failed to marshal event: %w", err)
	}

	// 发布消息
	err = eb.mq.Channel().PublishWithContext(
		ctx,
		ExchangeName, // 交换机
		eventType,    // routing key
		false,        // mandatory
		false,        // immediate
		amqp.Publishing{
			ContentType:  "application/json",
			DeliveryMode: amqp.Persistent, // 持久化消息
			Timestamp:    time.Now(),
			Body:         body,
		},
	)
	if err != nil {
		return fmt.Errorf("failed to publish event: %w", err)
	}

	eb.log.Debug("Event published",
		logger.String("type", eventType),
		logger.String("id", event.ID))

	return nil
}

// Subscribe 订阅事件
//
// pattern: 事件模式，支持通配符
//   - "user.blacklist.updated" 精确匹配
//   - "user.*" 匹配 user 下的所有事件
//   - "user.#" 匹配 user 下的所有事件（包括多级）
//   - "#" 匹配所有事件
func (eb *EventBus) Subscribe(pattern string, handler EventHandler) error {
	// 为该服务创建专属队列
	queueName := fmt.Sprintf("%s.%s", eb.serviceName, pattern)
	
	queue, err := eb.mq.DeclareQueue(queueName)
	if err != nil {
		return fmt.Errorf("failed to declare queue: %w", err)
	}

	// 绑定队列到交换机
	if err := eb.mq.BindQueue(queue.Name, pattern, ExchangeName); err != nil {
		return fmt.Errorf("failed to bind queue: %w", err)
	}

	// 注册 handler
	eb.handlers[pattern] = append(eb.handlers[pattern], handler)

	eb.log.Info("Subscribed to event",
		logger.String("pattern", pattern),
		logger.String("queue", queueName))

	return nil
}

// StartConsuming 开始消费消息（阻塞）
func (eb *EventBus) StartConsuming(ctx context.Context) error {
	for pattern, handlers := range eb.handlers {
		queueName := fmt.Sprintf("%s.%s", eb.serviceName, pattern)
		
		msgs, err := eb.mq.Channel().Consume(
			queueName,     // 队列名
			eb.serviceName, // 消费者标签
			false,         // auto-ack (手动确认)
			false,         // exclusive
			false,         // no-local
			false,         // no-wait
			nil,           // args
		)
		if err != nil {
			return fmt.Errorf("failed to consume queue %s: %w", queueName, err)
		}

		// 为每个队列启动消费者 goroutine
		go eb.consumeMessages(ctx, pattern, handlers, msgs)
	}

	return nil
}

// consumeMessages 消费消息
func (eb *EventBus) consumeMessages(ctx context.Context, pattern string, handlers []EventHandler, msgs <-chan amqp.Delivery) {
	for {
		select {
		case <-ctx.Done():
			eb.log.Info("Stopping consumer", logger.String("pattern", pattern))
			return
		case msg, ok := <-msgs:
			if !ok {
				eb.log.Warn("Message channel closed", logger.String("pattern", pattern))
				return
			}

			// 解析事件
			var event Event
			if err := json.Unmarshal(msg.Body, &event); err != nil {
				eb.log.Error("Failed to unmarshal event",
					logger.Error(err),
					logger.String("body", string(msg.Body)))
				msg.Nack(false, false) // 不重新入队
				continue
			}

			// 调用所有 handler
			var lastErr error
			for _, handler := range handlers {
				if err := handler(ctx, &event); err != nil {
					eb.log.Error("Event handler failed",
						logger.Error(err),
						logger.String("type", event.Type),
						logger.String("id", event.ID))
					lastErr = err
				}
			}

			// 确认消息
			if lastErr != nil {
				// 处理失败，重新入队（可以配置死信队列）
				msg.Nack(false, true)
			} else {
				msg.Ack(false)
				eb.log.Debug("Event processed",
					logger.String("type", event.Type),
					logger.String("id", event.ID))
			}
		}
	}
}

// ParseEventData 解析事件数据到指定类型
func ParseEventData[T any](event *Event) (*T, error) {
	var data T
	if err := json.Unmarshal(event.Data, &data); err != nil {
		return nil, fmt.Errorf("failed to parse event data: %w", err)
	}
	return &data, nil
}
