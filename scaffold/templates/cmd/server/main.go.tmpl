package main

import (
	"context"
	"fmt"
	"net"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/prometheus/client_golang/prometheus/promhttp"
	"google.golang.org/grpc"
	"google.golang.org/grpc/health"
	"google.golang.org/grpc/health/grpc_health_v1"

	"{{MODULE_PATH}}/internal/app"
	"{{MODULE_PATH}}/pkg/conf"
	"{{MODULE_PATH}}/pkg/logger"
	"{{MODULE_PATH}}/pkg/mq"
	"{{MODULE_PATH}}/pkg/scheduler"
	_ "{{MODULE_PATH}}/pkg/metrics" // åˆå§‹åŒ– Prometheus æŒ‡æ ‡
)

func main() {
	// 1. åˆå§‹åŒ–é…ç½®
	c := conf.Load()

	// 2. åˆå§‹åŒ–æ—¥å¿—
	log := logger.New(c.Log.Level, c.Log.Format)

	// 3. åˆå§‹åŒ– RabbitMQ
	rabbitMQ, err := mq.New(&mq.Config{
		Host:     c.RabbitMQ.Host,
		Port:     c.RabbitMQ.Port,
		User:     c.RabbitMQ.User,
		Password: c.RabbitMQ.Password,
		VHost:    c.RabbitMQ.VHost,
	}, log)
	if err != nil {
		log.Fatal("failed to connect to RabbitMQ", logger.Error(err))
	}

	// 4. åˆå§‹åŒ–äº‹ä»¶æ€»çº¿
	eventBus, err := mq.NewEventBus(rabbitMQ, "{{SERVICE_NAME}}", log)
	if err != nil {
		log.Fatal("failed to create event bus", logger.Error(err))
	}

	// 5. åˆå§‹åŒ–å®šæ—¶ä»»åŠ¡è°ƒåº¦å™¨
	sched := scheduler.New(log)

	// 6. æ„é€ åº”ç”¨å®ä¾‹
	application, err := app.New(c, log, eventBus, sched)
	if err != nil {
		log.Fatal("failed to initialize application", logger.Error(err))
	}

	// 7. å¯åŠ¨äº‹ä»¶æ¶ˆè´¹è€…
	ctx, cancel := context.WithCancel(context.Background())
	if err := eventBus.StartConsuming(ctx); err != nil {
		log.Fatal("failed to start event consuming", logger.Error(err))
	}

	// 8. å¯åŠ¨å®šæ—¶ä»»åŠ¡è°ƒåº¦å™¨
	sched.Start()

	// 9. å¯åŠ¨å¥åº·æ£€æŸ¥ HTTP æœåŠ¡å™¨
	healthServer := startHealthServer(c.Server.HTTPPort, log)

	// 10. å¯åŠ¨ gRPC æœåŠ¡å™¨
	lis, err := net.Listen("tcp", fmt.Sprintf(":%d", c.Server.GRPCPort))
	if err != nil {
		log.Fatal("failed to listen", logger.Int("port", c.Server.GRPCPort), logger.Error(err))
	}

	s := grpc.NewServer(
		app.NewGRPCInterceptors(log, c)...,
	)
	
	// æ³¨å†Œå¥åº·æ£€æŸ¥æœåŠ¡
	grpcHealthServer := health.NewServer()
	grpc_health_v1.RegisterHealthServer(s, grpcHealthServer)
	grpcHealthServer.SetServingStatus("", grpc_health_v1.HealthCheckResponse_SERVING)
	
	// æ³¨å†Œä¸šåŠ¡æœåŠ¡
	application.RegisterServers(s)

	// ä¼˜é›…ä¸­æ­¢å¤„ç†
	sigCh := make(chan os.Signal, 1)
	signal.Notify(sigCh, os.Interrupt, syscall.SIGTERM)
	
	go func() {
		<-sigCh
		log.Info("shutting down servers...")
		
		// è®¾ç½®å¥åº·æ£€æŸ¥ä¸ºä¸å¥åº·çŠ¶æ€
		grpcHealthServer.SetServingStatus("", grpc_health_v1.HealthCheckResponse_NOT_SERVING)
		
		// åœæ­¢äº‹ä»¶æ¶ˆè´¹
		cancel()
		
		// åœæ­¢å®šæ—¶ä»»åŠ¡
		<-sched.Stop().Done()
		
		// å…³é—­ RabbitMQ è¿æ¥
		rabbitMQ.Close()
		
		// ä¼˜é›…å…³é—­ gRPC æœåŠ¡å™¨
		go func() {
			s.GracefulStop()
		}()
		
		// ä¼˜é›…å…³é—­å¥åº·æ£€æŸ¥ HTTP æœåŠ¡å™¨
		shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer shutdownCancel()
		if err := healthServer.Shutdown(shutdownCtx); err != nil {
			log.Error("failed to shutdown health server", logger.Error(err))
		}
		
		log.Info("servers shutdown complete")
	}()

	log.Info("ğŸš€ {{SERVICE_TITLE}} Service started", logger.Int("port", c.Server.GRPCPort))
	if err := s.Serve(lis); err != nil && err != grpc.ErrServerStopped {
		log.Fatal("failed to serve", logger.Error(err))
	}
}

func startHealthServer(port int, log *logger.Logger) *http.Server {
	mux := http.NewServeMux()
	mux.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("OK"))
	})
	// Prometheus æŒ‡æ ‡ç«¯ç‚¹
	mux.Handle("/metrics", promhttp.Handler())
	
	server := &http.Server{
		Addr:    fmt.Sprintf(":%d", port),
		Handler: mux,
	}

	go func() {
		log.Info("ğŸ¥ Health server started", logger.Int("port", port))
		if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Error("health server error", logger.Error(err))
		}
	}()
	
	return server
}
