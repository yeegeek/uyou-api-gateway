package logic

import (
	"context"
	"strings"
	"time"

	"{{MODULE_PATH}}/internal/model"
	"{{MODULE_PATH}}/internal/repository"
	"{{MODULE_PATH}}/pkg/conf"
	"{{MODULE_PATH}}/pkg/errno"
	"{{MODULE_PATH}}/pkg/logger"
	
	// 如果使用 PostgreSQL，取消注释以下导入：
	// "database/sql"
	// "errors"
)

type Logic struct {
	conf  *conf.Config
	log   *logger.Logger
	repo  *repository.Repository
	cache *repository.CacheRepository // 可选的缓存层
}

func New(c *conf.Config, l *logger.Logger, r *repository.Repository) *Logic {
	return &Logic{
		conf:  c,
		log:   l,
		repo:  r,
		cache: nil, // 默认不启用缓存
	}
}

// WithCache 启用缓存支持（可选）
func (l *Logic) WithCache(cache *repository.CacheRepository) *Logic {
	l.cache = cache
	l.log.Info("Cache enabled for Logic layer")
	return l
}

// Create{{SERVICE_TITLE}} 创建{{SERVICE_NAME}}
func (l *Logic) Create{{SERVICE_TITLE}}(ctx context.Context, name string) (int64, error) {
	if strings.TrimSpace(name) == "" {
		return 0, errno.InvalidArgument.WithMessage("name is required")
	}
	l.log.Info("Creating {{SERVICE_NAME}}", logger.String("name", name))
	
	item := &model.{{SERVICE_TITLE}}{
		Name:      name,
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}
	
	if err := l.repo.Create{{SERVICE_TITLE}}(ctx, item); err != nil {
		l.log.Error("Failed to create {{SERVICE_NAME}}", logger.Error(err))
		return 0, l.handleError(err)
	}
	
	// 使列表缓存失效（因为数据有变化）
	if l.cache != nil {
		l.cache.InvalidateList(ctx)
	}
	
	return item.ID, nil
}

// Get{{SERVICE_TITLE}} 获取{{SERVICE_NAME}}
func (l *Logic) Get{{SERVICE_TITLE}}(ctx context.Context, id int64) (*model.{{SERVICE_TITLE}}, error) {
	// 尝试从缓存获取
	if l.cache != nil {
		var cached model.{{SERVICE_TITLE}}
		if hit, _ := l.cache.Get(ctx, l.cache.EntityKey(id), &cached); hit {
			l.log.Debug("Cache hit for {{SERVICE_NAME}}", logger.Int64("id", id))
			return &cached, nil
		}
	}
	
	item, err := l.repo.Get{{SERVICE_TITLE}}ByID(ctx, id)
	if err != nil {
		return nil, l.handleError(err)
	}
	if item == nil {
		return nil, errno.NotFound.WithMessage("{{SERVICE_NAME}} not found")
	}
	
	// 写入缓存
	if l.cache != nil {
		l.cache.Set(ctx, l.cache.EntityKey(id), item, repository.DefaultCacheTTL)
	}
	
	return item, nil
}

// Update{{SERVICE_TITLE}} 更新{{SERVICE_NAME}}
func (l *Logic) Update{{SERVICE_TITLE}}(ctx context.Context, id int64, name string) error {
	if strings.TrimSpace(name) == "" {
		return errno.InvalidArgument.WithMessage("name is required")
	}
	item, err := l.repo.Get{{SERVICE_TITLE}}ByID(ctx, id)
	if err != nil {
		return l.handleError(err)
	}
	if item == nil {
		return errno.NotFound.WithMessage("{{SERVICE_NAME}} not found")
	}
	
	item.Name = name
	item.UpdatedAt = time.Now()
	
	if err := l.repo.Update{{SERVICE_TITLE}}(ctx, item); err != nil {
		return l.handleError(err)
	}
	
	// 删除实体缓存并使列表缓存失效
	if l.cache != nil {
		l.cache.Delete(ctx, l.cache.EntityKey(id))
		l.cache.InvalidateList(ctx)
	}
	
	return nil
}

// Delete{{SERVICE_TITLE}} 删除{{SERVICE_NAME}}
func (l *Logic) Delete{{SERVICE_TITLE}}(ctx context.Context, id int64) error {
	if err := l.repo.Delete{{SERVICE_TITLE}}(ctx, id); err != nil {
		return l.handleError(err)
	}
	
	// 删除实体缓存并使列表缓存失效
	if l.cache != nil {
		l.cache.Delete(ctx, l.cache.EntityKey(id))
		l.cache.InvalidateList(ctx)
	}
	
	return nil
}

// List{{SERVICE_TITLE}}s 列表{{SERVICE_NAME}} (支持缓存)
func (l *Logic) List{{SERVICE_TITLE}}s(ctx context.Context, page, pageSize int) ([]*model.{{SERVICE_TITLE}}, int64, error) {
	// 参数规范化
	if page < 1 {
		page = 1
	}
	if pageSize < 1 {
		pageSize = 10
	}
	if pageSize > 100 {
		pageSize = 100
	}
	
	// 尝试从缓存获取
	if l.cache != nil {
		if cached, hit, _ := l.cache.GetList(ctx, page, pageSize); hit && cached != nil {
			l.log.Debug("List cache hit", logger.Int("page", page), logger.Int("pageSize", pageSize))
			return cached.Items, cached.Total, nil
		}
	}
	
	// 从数据库获取
	items, total, err := l.repo.List{{SERVICE_TITLE}}s(ctx, page, pageSize)
	if err != nil {
		return nil, 0, l.handleError(err)
	}
	
	// 写入缓存
	if l.cache != nil {
		l.cache.SetList(ctx, page, pageSize, items, total)
	}
	
	return items, total, nil
}

// handleError 根据错误类型返回具体的错误码
func (l *Logic) handleError(err error) error {
	if err == nil {
		return nil
	}
	
	// 如果已经是 Errno 类型，直接返回
	if _, ok := err.(errno.Errno); ok {
		return err
	}
	
	// 如果使用 PostgreSQL，取消注释以下代码：
	// // 处理 SQL 错误
	// if errors.Is(err, sql.ErrNoRows) {
	// 	return errno.NotFound
	// }
	// 
	// // 处理 PostgreSQL 错误（需要导入 github.com/lib/pq）
	// if pqErr, ok := err.(*pq.Error); ok {
	//     switch pqErr.Code {
	//     case "23505": // unique_violation
	//         return errno.AlreadyExists.WithMessage(pqErr.Message)
	//     case "23503": // foreign_key_violation
	//         return errno.InvalidArgument.WithMessage("Foreign key constraint violation")
	//     }
	// }
	
	// 默认返回内部错误
	return errno.InternalError.WithMessage(err.Error())
}
