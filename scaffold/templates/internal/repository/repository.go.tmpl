package repository

import (
	"context"
	"sync"

	"{{MODULE_PATH}}/internal/model"
	"{{MODULE_PATH}}/pkg/conf"
	"{{MODULE_PATH}}/pkg/logger"
)

type Repository struct {
	conf   *conf.Config
	log    *logger.Logger
	data   map[int64]*model.{{SERVICE_TITLE}} // Simple in-memory storage for demo
	nextID int64
	mu     sync.RWMutex
}

func New(c *conf.Config, l *logger.Logger) (*Repository, error) {
	return &Repository{
		conf:   c,
		log:    l,
		data:   make(map[int64]*model.{{SERVICE_TITLE}}),
		nextID: 1,
	}, nil
}

// Create{{SERVICE_TITLE}} creates a new {{SERVICE_NAME}}
func (r *Repository) Create{{SERVICE_TITLE}}(ctx context.Context, item *model.{{SERVICE_TITLE}}) error {
	r.mu.Lock()
	defer r.mu.Unlock()
	
	item.ID = r.nextID
	r.nextID++
	r.data[item.ID] = item
	return nil
}

// Get{{SERVICE_TITLE}}ByID gets a {{SERVICE_NAME}} by ID
func (r *Repository) Get{{SERVICE_TITLE}}ByID(ctx context.Context, id int64) (*model.{{SERVICE_TITLE}}, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()
	
	item, ok := r.data[id]
	if !ok {
		return nil, nil
	}
	return item, nil
}

// Update{{SERVICE_TITLE}} updates a {{SERVICE_NAME}}
func (r *Repository) Update{{SERVICE_TITLE}}(ctx context.Context, item *model.{{SERVICE_TITLE}}) error {
	r.mu.Lock()
	defer r.mu.Unlock()
	
	r.data[item.ID] = item
	return nil
}

// Delete{{SERVICE_TITLE}} deletes a {{SERVICE_NAME}}
func (r *Repository) Delete{{SERVICE_TITLE}}(ctx context.Context, id int64) error {
	r.mu.Lock()
	defer r.mu.Unlock()
	
	delete(r.data, id)
	return nil
}

// List{{SERVICE_TITLE}}s lists {{SERVICE_NAME}}s with pagination
func (r *Repository) List{{SERVICE_TITLE}}s(ctx context.Context, page, pageSize int) ([]*model.{{SERVICE_TITLE}}, int64, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()
	
	// 参数验证
	if page < 1 {
		page = 1
	}
	if pageSize < 1 {
		pageSize = 10
	}
	if pageSize > 100 {
		pageSize = 100 // 限制最大页面大小
	}
	
	// 获取总数
	total := int64(len(r.data))
	
	// 转换为切片并排序（按 ID 降序）
	var allItems []*model.{{SERVICE_TITLE}}
	for _, item := range r.data {
		allItems = append(allItems, item)
	}
	
	// 简单排序：按 ID 降序
	for i := 0; i < len(allItems)-1; i++ {
		for j := i + 1; j < len(allItems); j++ {
			if allItems[i].ID < allItems[j].ID {
				allItems[i], allItems[j] = allItems[j], allItems[i]
			}
		}
	}
	
	// 计算分页范围
	start := (page - 1) * pageSize
	end := start + pageSize
	
	if start >= len(allItems) {
		return []*model.{{SERVICE_TITLE}}{}, total, nil
	}
	
	if end > len(allItems) {
		end = len(allItems)
	}
	
	return allItems[start:end], total, nil
}
